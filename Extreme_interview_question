Volatile keyword:

Tells the compiler: “this variable may change outside normal program flow, don’t optimize it away.”

Without it → compiler may keep values in CPU registers or optimize out repeated reads.

With it → forces every access to actually read/write memory.
========================================================================================================================

What happens when right shift the signed integer value which is -ve?


1. Representation of negative numbers

In almost all modern systems, int is stored in two’s complement form.
Example (32-bit int):

-8  = 11111111 11111111 11111111 11111000

2. Right shift operator >>

There are two kinds of right shift:

Logical right shift: fills leftmost bits with 0. (used for unsigned types)

Arithmetic right shift: fills leftmost bits with the sign bit (preserves the sign). (used for signed types on most compilers)

3. What C standard says

For unsigned types: right shift is always logical (fill with 0).

For signed negative values: implementation-defined (compiler/architecture decides).
→ On most modern CPUs (like x86, GCC/Clang/MSVC), it’s arithmetic shift, meaning the sign bit is replicated.


#include <stdio.h>

int main() {
    int x = -8;
    int y = x >> 1;

    printf("x = %d\n", x);
    printf("y = %d\n", y);

    return 0;
}

On a system with 32-bit int and arithmetic right shift:

x = -8        // binary: 11111111 11111111 11111111 11111000
x >> 1 = -4   // binary: 11111111 11111111 11111111 11111100


5. Summary

Unsigned right shift: always logical (fills with 0).

Signed negative right shift:

Arithmetic shift (common) → fills with sign bit, result stays negative.

Logical shift (rare systems) → fills with 0, result could become large positive.

Standard: implementation-defined.
========================================================================================================================

Reverse the bit only the the no of bits.

#include <stdio.h>

// Function to reverse bits only up to the number of bits in n
unsigned int reverseBits(unsigned int n) {
    unsigned int rev = 0;
    int num_bits = 0;
    unsigned int temp = n;

    // count how many bits are actually needed
    while (temp > 0) {
        num_bits++;
        temp >>= 1;
    }

    // reverse only num_bits
    for (int i = 0; i < num_bits; i++) {
        rev <<= 1;          // shift result left
        rev |= (n & 1);     // copy last bit of n
        n >>= 1;            // move to next bit
    }

    return rev;
}

what happens when the integer is signed int and holding negative value

n doesnt end with only n of bits it counts to 32 bit as MSB of negative value holds 1
========================================================================================================================

Count the no of set bit in a integer

#include <stdio.h>

int countSetBits(int n) {
    int count = 0;
    while (n) {
        n = n & (n - 1);  // remove last set bit
        count++;
    }
    return count;
}

int main() {
    int num = 29; // binary: 11101
    printf("Number of set bits in %d is %d\n", num, countSetBits(num));
    return 0;
}
========================================================================================================================

C program to find the endianess

#include <stdio.h>

int main() {
    unsigned int x = 0x12345678;
    char *c = (char*)&x;

    if (*c==0x78) {
        printf("Little Endian\n");
    } else {
        printf("Big Endian\n");
    }

    return 0;
}
=========================================================================================================================

Output of following code


#include <stdio.h>

int main() {
    unsigned int a = 5;
    int b = -15;
    printf("The value of c is :%d\n",c);
    if(a+b < 5) {
        printf("less\n");
    }
    else {
        printf("Greater\n");
    }

    return 0;
}


In mixed signed + unsigned arithmetic, the signed int b is converted to unsigned. So Greater will be printed
===========================================================================================================================

What happens when the following code execute


void a() {
    int x;
    int y;
    x=100;
}
void b() {
    int z;
    printf("The value of %d\n",++z);
}
int main() {
    a();
    b();
    b();
    b();

    return 0;
}

Key points:

In a():

x and y are local variables.

They exist only while the function executes and then go out of scope.

x = 100; assigns a value, but since nothing is printed or returned, it does nothing visible.

In b():

int z; is a local variable.

It is not initialized, so it contains a garbage value (whatever random data was in that memory location).

When you do ++z, you increment garbage → undefined behavior.

So the output will be unpredictable (different values each run, or even crashing).


The following also can happen
*****************************
z is a local variable.

Since it’s not initialized, its value is whatever junk is left in that stack location.

The trick: when you call a(), the function allocates space for its locals (x, y) on the stack. After a() returns, the memory is reused for b()’s local z.

Since x was set to 100, that stack slot still has 100 in it when b() runs.

So z starts with 100 (by accident) → ++z gives 101.

Next call to b(), the same memory slot is reused, now containing 101 → incremented to 102.

Then 103, and so on.
=================================================================================================================================

What is top half and bottom half? Spinlocks
About Linux programming. What I have done in my previous projects

=================================================================================================================================

Count the no of difference bit between two integer


#include <stdio.h>

// Function to count set bits using Brian Kernighan's Algorithm
int countSetBits(int n) {
    int count = 0;
    while (n) {
        n = n & (n - 1); // remove last set bit
        count++;
    }
    return count;
}

// Function to count number of different bits between a and b
int countDifferentBits(int a, int b) {
    int xor = a ^ b;       // XOR to get different bits
    return countSetBits(xor);
}

int main() {
    int x = 29;  // 11101
    int y = 15;  // 01111

    printf("Number of different bits: %d\n", countDifferentBits(x, y));
    return 0;
}

================================================================================================================================

Remove space from a string using pointer

#include <stdio.h>

void removeSpaces(char *str) {
    char *read = str;   // pointer to read the original string
    char *write = str;  // pointer to write characters without spaces

    while (*read != '\0') {
        if (*read != ' ') {     // copy only non-space characters
            *write = *read;
            write++;
        }
        read++;
    }
    *write = '\0';  // terminate the new string
}

int main() {
    char str[] = "H e l l o   W o r l d";
    printf("Original string: \"%s\"\n", str);

    removeSpaces(str);
    printf("String without spaces: \"%s\"\n", str);

    return 0;
}
============================================================================================================================
Swap the little Endian to Big Endian

#include<stdio.h>
int main() {
	unsigned int num = 0x12345678;
	
	unsigned int swapped = (((num>>24)&0xff)|((num>>8)&0xff00)|((num<<24)&0xff000000)|((num<<8)&0xff0000));
	printf("%0x\n",swapped);
	return 0;
}
============================================================================================================================
what SRC and Dest mac/IP address in 802.3 packet when ping to google happens

When you ping Google (for example 8.8.8.8), there are two layers of addressing involved:

Layer 3 (IP layer) — used end-to-end (source → destination across the Internet)

Layer 2 (Ethernet / IEEE 802.3 layer) — used only within your local network hop (source → gateway)

Let’s separate them carefully:

🔹 Layer 3: IP addresses inside the packet

The IP header (which sits inside the Ethernet frame) will contain:

Field	Example	Notes
Source IP	192.168.1.10	Your system’s private IP address
Destination IP	8.8.8.8	Google’s public IP address (the one you ping)

✅ These don’t change as the packet travels through routers.
Every router forwards the same IP addresses.

🔹 Layer 2: MAC addresses on the Ethernet frame (802.3)

The Ethernet (802.3) header wraps around the IP packet, and it’s only valid between directly connected devices — your PC and your gateway.

Field	Example	Meaning
Source MAC	AA:AA:AA:AA:AA:AA	Your computer’s NIC MAC address
Destination MAC	BB:BB:BB:BB:BB:BB	Your router/gateway’s MAC address
EtherType	0x0800	Indicates payload is IPv4

✅ These change at every hop — once your router forwards the packet to the next router, it replaces the Ethernet header with new source/destination MACs relevant to that link.

============================================================================================================================

Machine A → Router1 (MTU 1500) → Router2 (MTU 1200) → Router3 (MTU 1000) → Machine B

Now Machine A wants to send a UDP packet to Machine B.


Two cases — depends on IP header flag: DF (Don’t Fragment)
🅰️ Case 1: DF bit = 0 (Fragmentation allowed)

Then intermediate routers can fragment the packet.

✅ How it works:

Machine A sends a 1500-byte UDP packet.

Router1 passes (MTU=1500) → OK

Router2 MTU=1200 → packet too big → Router2 fragments it:

Fragment 1: bytes 0–1199

Fragment 2: bytes 1200–1499

Router3 (MTU=1000) → fragments again if needed.

Machine B receives multiple IP fragments and reassembles them to reconstruct the original UDP datagram.

⚠️ Disadvantage:
Fragmentation adds overhead and reduces performance — and if any fragment is lost, the entire packet is discarded.

🅱️ Case 2: DF bit = 1 (Don’t Fragment) → common today

Modern systems set the DF flag and use Path MTU Discovery (PMTUD) instead.

✅ How it works:

Machine A sends 1500-byte packet with DF=1.

Router2 (MTU=1200) drops it — cannot forward (too big).

Router2 sends back an ICMP “Fragmentation Needed” message (Type 3, Code 4) telling A:

Hey! I can only handle 1200 bytes.


Machine A learns that the path MTU = 1200 and reduces its packet size accordingly.

It retransmits smaller packets that fit (≤1200 bytes).

If later Router3 (MTU=1000) also drops packets, A will reduce again — until all routers accept the size.

============================================================================================================================
