Volatile keyword:

Tells the compiler: â€œthis variable may change outside normal program flow, donâ€™t optimize it away.â€

Without it â†’ compiler may keep values in CPU registers or optimize out repeated reads.

With it â†’ forces every access to actually read/write memory.
========================================================================================================================

What happens when right shift the signed integer value which is -ve?


1. Representation of negative numbers

In almost all modern systems, int is stored in twoâ€™s complement form.
Example (32-bit int):

-8  = 11111111 11111111 11111111 11111000

2. Right shift operator >>

There are two kinds of right shift:

Logical right shift: fills leftmost bits with 0. (used for unsigned types)

Arithmetic right shift: fills leftmost bits with the sign bit (preserves the sign). (used for signed types on most compilers)

3. What C standard says

For unsigned types: right shift is always logical (fill with 0).

For signed negative values: implementation-defined (compiler/architecture decides).
â†’ On most modern CPUs (like x86, GCC/Clang/MSVC), itâ€™s arithmetic shift, meaning the sign bit is replicated.


#include <stdio.h>

int main() {
    int x = -8;
    int y = x >> 1;

    printf("x = %d\n", x);
    printf("y = %d\n", y);

    return 0;
}

On a system with 32-bit int and arithmetic right shift:

x = -8        // binary: 11111111 11111111 11111111 11111000
x >> 1 = -4   // binary: 11111111 11111111 11111111 11111100


5. Summary

Unsigned right shift: always logical (fills with 0).

Signed negative right shift:

Arithmetic shift (common) â†’ fills with sign bit, result stays negative.

Logical shift (rare systems) â†’ fills with 0, result could become large positive.

Standard: implementation-defined.
========================================================================================================================

Reverse the bit only the the no of bits.

#include <stdio.h>

// Function to reverse bits only up to the number of bits in n
unsigned int reverseBits(unsigned int n) {
    unsigned int rev = 0;
    int num_bits = 0;
    unsigned int temp = n;

    // count how many bits are actually needed
    while (temp > 0) {
        num_bits++;
        temp >>= 1;
    }

    // reverse only num_bits
    for (int i = 0; i < num_bits; i++) {
        rev <<= 1;          // shift result left
        rev |= (n & 1);     // copy last bit of n
        n >>= 1;            // move to next bit
    }

    return rev;
}

what happens when the integer is signed int and holding negative value

n doesnt end with only n of bits it counts to 32 bit as MSB of negative value holds 1
========================================================================================================================

Count the no of set bit in a integer

#include <stdio.h>

int countSetBits(int n) {
    int count = 0;
    while (n) {
        n = n & (n - 1);  // remove last set bit
        count++;
    }
    return count;
}

int main() {
    int num = 29; // binary: 11101
    printf("Number of set bits in %d is %d\n", num, countSetBits(num));
    return 0;
}
========================================================================================================================

C program to find the endianess

#include <stdio.h>

int main() {
    unsigned int x = 0x12345678;
    char *c = (char*)&x;

    if (*c==0x78) {
        printf("Little Endian\n");
    } else {
        printf("Big Endian\n");
    }

    return 0;
}
=========================================================================================================================

Output of following code


#include <stdio.h>

int main() {
    unsigned int a = 5;
    int b = -15;
    printf("The value of c is :%d\n",c);
    if(a+b < 5) {
        printf("less\n");
    }
    else {
        printf("Greater\n");
    }

    return 0;
}


In mixed signed + unsigned arithmetic, the signed int b is converted to unsigned. So Greater will be printed
===========================================================================================================================

What happens when the following code execute


void a() {
    int x;
    int y;
    x=100;
}
void b() {
    int z;
    printf("The value of %d\n",++z);
}
int main() {
    a();
    b();
    b();
    b();

    return 0;
}

Key points:

In a():

x and y are local variables.

They exist only while the function executes and then go out of scope.

x = 100; assigns a value, but since nothing is printed or returned, it does nothing visible.

In b():

int z; is a local variable.

It is not initialized, so it contains a garbage value (whatever random data was in that memory location).

When you do ++z, you increment garbage â†’ undefined behavior.

So the output will be unpredictable (different values each run, or even crashing).


The following also can happen
*****************************
z is a local variable.

Since itâ€™s not initialized, its value is whatever junk is left in that stack location.

The trick: when you call a(), the function allocates space for its locals (x, y) on the stack. After a() returns, the memory is reused for b()â€™s local z.

Since x was set to 100, that stack slot still has 100 in it when b() runs.

So z starts with 100 (by accident) â†’ ++z gives 101.

Next call to b(), the same memory slot is reused, now containing 101 â†’ incremented to 102.

Then 103, and so on.
=================================================================================================================================

What is top half and bottom half? Spinlocks
About Linux programming. What I have done in my previous projects

=================================================================================================================================

Count the no of difference bit between two integer


#include <stdio.h>

// Function to count set bits using Brian Kernighan's Algorithm
int countSetBits(int n) {
    int count = 0;
    while (n) {
        n = n & (n - 1); // remove last set bit
        count++;
    }
    return count;
}

// Function to count number of different bits between a and b
int countDifferentBits(int a, int b) {
    int xor = a ^ b;       // XOR to get different bits
    return countSetBits(xor);
}

int main() {
    int x = 29;  // 11101
    int y = 15;  // 01111

    printf("Number of different bits: %d\n", countDifferentBits(x, y));
    return 0;
}

================================================================================================================================

Remove space from a string using pointer

#include <stdio.h>

void removeSpaces(char *str) {
    char *read = str;   // pointer to read the original string
    char *write = str;  // pointer to write characters without spaces

    while (*read != '\0') {
        if (*read != ' ') {     // copy only non-space characters
            *write = *read;
            write++;
        }
        read++;
    }
    *write = '\0';  // terminate the new string
}

int main() {
    char str[] = "H e l l o   W o r l d";
    printf("Original string: \"%s\"\n", str);

    removeSpaces(str);
    printf("String without spaces: \"%s\"\n", str);

    return 0;
}
============================================================================================================================
Swap the little Endian to Big Endian

#include<stdio.h>
int main() {
	unsigned int num = 0x12345678;
	
	unsigned int swapped = (((num>>24)&0xff)|((num>>8)&0xff00)|((num<<24)&0xff000000)|((num<<8)&0xff0000));
	printf("%0x\n",swapped);
	return 0;
}
============================================================================================================================
what SRC and Dest mac/IP address in 802.3 packet when ping to google happens

When you ping Google (for example 8.8.8.8), there are two layers of addressing involved:

Layer 3 (IP layer) â€” used end-to-end (source â†’ destination across the Internet)

Layer 2 (Ethernet / IEEE 802.3 layer) â€” used only within your local network hop (source â†’ gateway)

Letâ€™s separate them carefully:

ðŸ”¹ Layer 3: IP addresses inside the packet

The IP header (which sits inside the Ethernet frame) will contain:

Field	Example	Notes
Source IP	192.168.1.10	Your systemâ€™s private IP address
Destination IP	8.8.8.8	Googleâ€™s public IP address (the one you ping)

âœ… These donâ€™t change as the packet travels through routers.
Every router forwards the same IP addresses.

ðŸ”¹ Layer 2: MAC addresses on the Ethernet frame (802.3)

The Ethernet (802.3) header wraps around the IP packet, and itâ€™s only valid between directly connected devices â€” your PC and your gateway.

Field	Example	Meaning
Source MAC	AA:AA:AA:AA:AA:AA	Your computerâ€™s NIC MAC address
Destination MAC	BB:BB:BB:BB:BB:BB	Your router/gatewayâ€™s MAC address
EtherType	0x0800	Indicates payload is IPv4

âœ… These change at every hop â€” once your router forwards the packet to the next router, it replaces the Ethernet header with new source/destination MACs relevant to that link.

============================================================================================================================

Machine A â†’ Router1 (MTU 1500) â†’ Router2 (MTU 1200) â†’ Router3 (MTU 1000) â†’ Machine B

Now Machine A wants to send a UDP packet to Machine B.


Two cases â€” depends on IP header flag: DF (Donâ€™t Fragment)
ðŸ…°ï¸ Case 1: DF bit = 0 (Fragmentation allowed)

Then intermediate routers can fragment the packet.

âœ… How it works:

Machine A sends a 1500-byte UDP packet.

Router1 passes (MTU=1500) â†’ OK

Router2 MTU=1200 â†’ packet too big â†’ Router2 fragments it:

Fragment 1: bytes 0â€“1199

Fragment 2: bytes 1200â€“1499

Router3 (MTU=1000) â†’ fragments again if needed.

Machine B receives multiple IP fragments and reassembles them to reconstruct the original UDP datagram.

âš ï¸ Disadvantage:
Fragmentation adds overhead and reduces performance â€” and if any fragment is lost, the entire packet is discarded.

ðŸ…±ï¸ Case 2: DF bit = 1 (Donâ€™t Fragment) â†’ common today

Modern systems set the DF flag and use Path MTU Discovery (PMTUD) instead.

âœ… How it works:

Machine A sends 1500-byte packet with DF=1.

Router2 (MTU=1200) drops it â€” cannot forward (too big).

Router2 sends back an ICMP â€œFragmentation Neededâ€ message (Type 3, Code 4) telling A:

Hey! I can only handle 1200 bytes.


Machine A learns that the path MTU = 1200 and reduces its packet size accordingly.

It retransmits smaller packets that fit (â‰¤1200 bytes).

If later Router3 (MTU=1000) also drops packets, A will reduce again â€” until all routers accept the size.

============================================================================================================================
